/**
 * Handler for search-work-items tool
 * Provides full-text search across work item fields
 */

import type { ToolConfig, ToolExecutionResult, ToolExecutionData } from "@/types/index.js";
import { logger } from "@/utils/logger.js";
import { searchService, type SearchResult, type SearchOptions } from "../../search-service.js";
import { queryHandleService } from "../../query-handle-service.js";
import { handleGetWorkItemContextPackage } from "../context/get-work-item-context-package.handler.js";

interface SearchWorkItemsArgs {
  queryHandle?: string;
  query: string;
  fields?: ('title' | 'description' | 'comments' | 'acceptanceCriteria' | 'tags' | 'all')[];
  maxResults?: number;
  fuzzyThreshold?: number;
  filterByType?: string[];
  filterByState?: string[];
  filterByAssignee?: string;
  includeHighlights?: boolean;
  buildIndexFromHandle?: boolean;
  saveIndex?: boolean;
}

/**
 * Search work items using full-text search
 */
export async function handleSearchWorkItems(config: ToolConfig, args: unknown): Promise<ToolExecutionResult> {
  try {
    const parsed = args as SearchWorkItemsArgs;

    // Initialize search service
    await searchService.initialize();

    // Build index from query handle if requested
    if (parsed.buildIndexFromHandle && parsed.queryHandle) {
      await buildIndexFromQueryHandle(parsed.queryHandle);
    }

    // Perform search
    const searchOptions: SearchOptions = {
      fields: parsed.fields,
      maxResults: parsed.maxResults || 50,
      fuzzyThreshold: parsed.fuzzyThreshold || 0.8,
      filterByType: parsed.filterByType,
      filterByState: parsed.filterByState,
      filterByAssignee: parsed.filterByAssignee,
      includeHighlights: parsed.includeHighlights !== false
    };

    const results = await searchService.search(parsed.query, searchOptions);

    // Save index if requested
    if (parsed.saveIndex) {
      await searchService.saveIndex();
    }

    const stats = searchService.getStats();

    const data: ToolExecutionData = {
      query: parsed.query,
      results_count: results.length,
      index_stats: {
        total_documents: stats.totalDocuments,
        last_updated: stats.lastUpdated.toISOString(),
        index_size_kb: (stats.indexSize / 1024).toFixed(2)
      },
      results: results.map(r => ({
        id: r.id,
        title: r.title,
        type: r.type,
        state: r.state,
        score: r.score.toFixed(2),
        url: r.url,
        highlights: r.highlights.map(h => ({
          field: h.field,
          snippet: h.snippet,
          matched_terms: h.matchedTerms
        }))
      })),
      search_options: {
        fields: searchOptions.fields,
        fuzzy_threshold: searchOptions.fuzzyThreshold,
        filters: {
          type: parsed.filterByType,
          state: parsed.filterByState,
          assignee: parsed.filterByAssignee
        }
      }
    };

    return {
      success: true,
      data,
      metadata: {},
      errors: [],
      warnings: []
    };
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    logger.error(`Search work items error: ${errorMsg}`);

    return {
      success: false,
      data: {
        hint: 'Build the search index first using buildIndexFromHandle=true with a query handle'
      },
      metadata: {},
      errors: [errorMsg],
      warnings: []
    };
  }
}

/**
 * Build search index from a query handle
 */
async function buildIndexFromQueryHandle(queryHandle: string): Promise<void> {
  const queryData = queryHandleService.getQueryData(queryHandle);
  if (!queryData) {
    throw new Error(`Query handle not found: ${queryHandle}`);
  }

  logger.info(`Building search index from query handle: ${queryHandle} (${queryData.workItemIds.length} items)`);

  const startTime = Date.now();
  const itemsToIndex = [];

  // Fetch full context for each work item
  for (const id of queryData.workItemIds) {
    try {
      const context = await handleGetWorkItemContextPackage({
        workItemId: id,
        includeRelations: false,
        includeHistory: false,
        includeComments: true,
        includeChildren: false,
        includeParent: false,
        includeTags: true
      });

      if (!context.success || !context.data) {
        logger.warn(`Failed to fetch context for work item ${id}, skipping`);
        continue;
      }

      const workItemData = context.data as Record<string, any>;
      const item = workItemData.work_item;

      itemsToIndex.push({
        id: item.id,
        title: item.title,
        description: item.description,
        acceptanceCriteria: item.acceptance_criteria,
        comments: workItemData.comments?.map((c: any) => c.text) || [],
        tags: item.tags,
        state: item.state,
        type: item.type,
        assignedTo: item.assigned_to,
        url: item.url,
        changedDate: item.changed_date
      });
    } catch (error) {
      logger.warn(`Error fetching work item ${id}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  // Index all items
  await searchService.indexWorkItems(itemsToIndex);

  const elapsed = Date.now() - startTime;
  logger.info(`Built search index in ${elapsed}ms: ${itemsToIndex.length} items indexed`);
}
