/**
 * Time Tracking Service
 * 
 * Manages work item time tracking with start/stop tracking, manual entry,
 * and reporting. Integrates with ADO scheduling fields.
 */

import { logger, errorToContext } from '../utils/logger.js';
import { v4 as uuidv4 } from 'uuid';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';
import type {
  TimeEntry,
  ActiveTimer,
  TimeReport,
  TimeTrackingSession,
  WorkItemTimeSummary,
  TimeTrackingConfig,
  StartTrackingArgs,
  StopTrackingArgs,
  LogWorkTimeArgs,
  GetTimeReportArgs,
  PauseResumeTrackingArgs,
  TimeTrackingResult,
  ActiveTimersSummary,
  TimeLogComment
} from '../types/time-tracking.js';
import { createWorkItemRepository } from '../repositories/work-item.repository.js';
import type { ADOFieldOperation } from '../types/ado.js';

/**
 * Default configuration
 */
const DEFAULT_CONFIG: TimeTrackingConfig = {
  autoPauseAfterMinutes: 30,
  roundToMinutes: 15,
  minimumDurationMinutes: 1,
  enableBillableTracking: true,
  storageFile: path.join(os.tmpdir(), 'ado-time-tracking.json')
};

/**
 * In-memory storage for active timers
 */
interface StorageData {
  activeTimers: Map<string, ActiveTimer>;
  timeEntries: Map<string, TimeEntry>;
  sessions: Map<string, TimeTrackingSession>;
}

class TimeTrackingService {
  private config: TimeTrackingConfig;
  private storage: StorageData;
  private storageLoaded: boolean = false;

  constructor(config?: Partial<TimeTrackingConfig>) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.storage = {
      activeTimers: new Map(),
      timeEntries: new Map(),
      sessions: new Map()
    };
  }

  /**
   * Load storage from disk
   */
  private async loadStorage(): Promise<void> {
    if (this.storageLoaded) return;

    try {
      const data = await fs.readFile(this.config.storageFile, 'utf-8');
      const parsed = JSON.parse(data);

      this.storage.activeTimers = new Map(Object.entries(parsed.activeTimers || {}));
      this.storage.timeEntries = new Map(Object.entries(parsed.timeEntries || {}));
      this.storage.sessions = new Map(Object.entries(parsed.sessions || {}));

      this.storageLoaded = true;
      logger.debug('[TimeTracking] Storage loaded from disk');
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        logger.debug('[TimeTracking] No storage file found, starting fresh');
        this.storageLoaded = true;
      } else {
        logger.warn('[TimeTracking] Failed to load storage', errorToContext(error));
      }
    }
  }

  /**
   * Save storage to disk
   */
  private async saveStorage(): Promise<void> {
    try {
      const data = {
        activeTimers: Object.fromEntries(this.storage.activeTimers),
        timeEntries: Object.fromEntries(this.storage.timeEntries),
        sessions: Object.fromEntries(this.storage.sessions),
        savedAt: new Date().toISOString()
      };

      await fs.writeFile(
        this.config.storageFile,
        JSON.stringify(data, null, 2),
        'utf-8'
      );

      logger.debug('[TimeTracking] Storage saved to disk');
    } catch (error) {
      logger.error('[TimeTracking] Failed to save storage', errorToContext(error));
    }
  }

  /**
   * Get timer key for a work item and user
   */
  private getTimerKey(workItemId: number, user: string): string {
    return `${workItemId}:${user}`;
  }

  /**
   * Get current user (from environment or default)
   */
  private getCurrentUser(): string {
    return process.env.USER_EMAIL || process.env.USERNAME || 'unknown';
  }

  /**
   * Calculate duration between two timestamps in hours
   */
  private calculateDuration(start: string, end: string): number {
    const startTime = new Date(start).getTime();
    const endTime = new Date(end).getTime();
    const durationMs = endTime - startTime;
    return durationMs / (1000 * 60 * 60); // Convert to hours
  }

  /**
   * Round duration to nearest interval
   */
  private roundDuration(hours: number): number {
    const minutes = hours * 60;
    const roundTo = this.config.roundToMinutes;
    const rounded = Math.round(minutes / roundTo) * roundTo;
    return rounded / 60;
  }

  /**
   * Format time log comment
   */
  private formatTimeLogComment(entry: TimeLogComment): string {
    const { date, startTime, endTime, duration, user, description, entryType } = entry;
    const desc = description ? ` - ${description}` : '';
    const type = entryType === 'manual' ? ' (manual entry)' : '';
    return `[Time Log] ${date} ${startTime}-${endTime} (${duration.toFixed(2)}h)${desc}${type} - ${user}`;
  }

  /**
   * Update work item scheduling fields
   */
  private async updateWorkItemFields(
    organization: string,
    project: string,
    workItemId: number,
    hoursToAdd: number
  ): Promise<void> {
    const repository = createWorkItemRepository(organization, project);
    const workItem = await repository.getById(workItemId);

    const currentCompleted = (workItem.fields['Microsoft.VSTS.Scheduling.CompletedWork'] as number) || 0;
    const currentRemaining = (workItem.fields['Microsoft.VSTS.Scheduling.RemainingWork'] as number) || null;

    const newCompleted = currentCompleted + hoursToAdd;
    const newRemaining = currentRemaining !== null ? Math.max(0, currentRemaining - hoursToAdd) : null;

    const updates: ADOFieldOperation[] = [
      { op: 'replace', path: '/fields/Microsoft.VSTS.Scheduling.CompletedWork', value: newCompleted }
    ];

    if (newRemaining !== null) {
      updates.push({ op: 'replace', path: '/fields/Microsoft.VSTS.Scheduling.RemainingWork', value: newRemaining });
    }

    await repository.update(workItemId, updates);
    logger.debug(`[TimeTracking] Updated work item ${workItemId} fields: CompletedWork=${newCompleted}, RemainingWork=${newRemaining}`);
  }

  /**
   * Add time log comment to work item
   */
  private async addTimeLogComment(
    organization: string,
    project: string,
    workItemId: number,
    comment: string
  ): Promise<void> {
    const repository = createWorkItemRepository(organization, project);
    await repository.addComment(workItemId, comment);
    logger.debug(`[TimeTracking] Added time log comment to work item ${workItemId}`);
  }

  /**
   * Start time tracking for a work item
   */
  async startTracking(args: StartTrackingArgs): Promise<TimeTrackingResult> {
    await this.loadStorage();

    const { workItemId, organization, project, description, billable } = args;
    const user = this.getCurrentUser();
    const timerKey = this.getTimerKey(workItemId, user);

    // Check if already tracking
    if (this.storage.activeTimers.has(timerKey)) {
      const existing = this.storage.activeTimers.get(timerKey)!;
      return {
        success: false,
        message: `Already tracking work item ${workItemId}`,
        error: 'ALREADY_TRACKING',
        data: {
          workItemId,
          startTime: existing.startTime,
          status: existing.status
        }
      };
    }

    // Verify work item exists
    try {
      const repository = createWorkItemRepository(organization, project);
      const workItem = await repository.getById(workItemId);
      
      const timer: ActiveTimer = {
        workItemId,
        startTime: new Date().toISOString(),
        user,
        description,
        status: 'active',
        totalPausedDuration: 0
      };

      this.storage.activeTimers.set(timerKey, timer);
      await this.saveStorage();

      logger.info(`[TimeTracking] Started tracking work item ${workItemId} for ${user}`);

      return {
        success: true,
        message: `Started tracking work item ${workItemId}: ${workItem.fields['System.Title']}`,
        data: {
          workItemId,
          startTime: timer.startTime,
          title: workItem.fields['System.Title']
        }
      };
    } catch (error) {
      logger.error(`[TimeTracking] Failed to start tracking work item ${workItemId}`, errorToContext(error));
      return {
        success: false,
        message: `Failed to start tracking: ${error instanceof Error ? error.message : String(error)}`,
        error: 'START_FAILED'
      };
    }
  }

  /**
   * Stop time tracking for a work item
   */
  async stopTracking(args: StopTrackingArgs): Promise<TimeTrackingResult> {
    await this.loadStorage();

    const { workItemId, organization, project, description, updateFields = true } = args;
    const user = this.getCurrentUser();

    // Find active timer
    let timerKey: string | null = null;
    let activeWorkItemId: number;

    if (workItemId) {
      timerKey = this.getTimerKey(workItemId, user);
      activeWorkItemId = workItemId;
    } else {
      // Find any active timer for user
      for (const [key, timer] of this.storage.activeTimers.entries()) {
        if (timer.user === user && timer.status === 'active') {
          timerKey = key;
          activeWorkItemId = timer.workItemId;
          break;
        }
      }
    }

    if (!timerKey || !this.storage.activeTimers.has(timerKey)) {
      return {
        success: false,
        message: 'No active timer found',
        error: 'NO_ACTIVE_TIMER'
      };
    }

    const timer = this.storage.activeTimers.get(timerKey)!;
    const endTime = new Date().toISOString();
    let duration = this.calculateDuration(timer.startTime, endTime);
    
    // Subtract paused time
    duration -= timer.totalPausedDuration;
    
    // Round duration
    duration = this.roundDuration(duration);

    // Check minimum duration
    if (duration * 60 < this.config.minimumDurationMinutes) {
      return {
        success: false,
        message: `Duration (${duration.toFixed(2)}h) is below minimum (${this.config.minimumDurationMinutes}min)`,
        error: 'DURATION_TOO_SHORT'
      };
    }

    // Create time entry
    const entry: TimeEntry = {
      id: uuidv4(),
      workItemId: activeWorkItemId,
      startTime: timer.startTime,
      endTime,
      duration,
      user,
      description: description || timer.description,
      entryType: 'automatic',
      billable: timer.billable,
      status: 'completed',
      createdAt: timer.startTime,
      updatedAt: endTime
    };

    this.storage.timeEntries.set(entry.id, entry);
    this.storage.activeTimers.delete(timerKey);
    await this.saveStorage();

    // Update ADO fields
    try {
      if (updateFields) {
        await this.updateWorkItemFields(organization, project, activeWorkItemId, duration);
      }

      // Add time log comment
      const timeLog: TimeLogComment = {
        date: new Date(timer.startTime).toISOString().split('T')[0],
        startTime: new Date(timer.startTime).toISOString().split('T')[1].substring(0, 5),
        endTime: new Date(endTime).toISOString().split('T')[1].substring(0, 5),
        duration,
        user,
        description: entry.description,
        entryType: 'automatic'
      };

      await this.addTimeLogComment(organization, project, activeWorkItemId, this.formatTimeLogComment(timeLog));

      // Get updated fields
      const repository = createWorkItemRepository(organization, project);
      const workItem = await repository.getById(activeWorkItemId);
      const completedWork = (workItem.fields['Microsoft.VSTS.Scheduling.CompletedWork'] as number) || 0;
      const remainingWork = (workItem.fields['Microsoft.VSTS.Scheduling.RemainingWork'] as number) || null;
      const percentComplete = remainingWork !== null
        ? Math.round((completedWork / (completedWork + remainingWork)) * 100)
        : 100;

      logger.info(`[TimeTracking] Stopped tracking work item ${activeWorkItemId}, logged ${duration.toFixed(2)}h`);

      return {
        success: true,
        message: `Stopped tracking work item ${activeWorkItemId}, logged ${duration.toFixed(2)} hours`,
        data: {
          workItemId: activeWorkItemId,
          duration,
          startTime: timer.startTime,
          endTime,
          completedWork,
          remainingWork: remainingWork || undefined,
          percentComplete
        }
      };
    } catch (error) {
      logger.error(`[TimeTracking] Failed to update work item ${activeWorkItemId}`, errorToContext(error));
      return {
        success: false,
        message: `Time tracked but failed to update work item: ${error instanceof Error ? error.message : String(error)}`,
        error: 'UPDATE_FAILED',
        data: {
          workItemId: activeWorkItemId,
          duration,
          startTime: timer.startTime,
          endTime
        }
      };
    }
  }

  /**
   * Pause/resume time tracking
   */
  async pauseResumeTracking(args: PauseResumeTrackingArgs): Promise<TimeTrackingResult> {
    await this.loadStorage();

    const { workItemId, organization, project, action } = args;
    const user = this.getCurrentUser();

    // Find active timer
    let timerKey: string | null = null;

    if (workItemId) {
      timerKey = this.getTimerKey(workItemId, user);
    } else {
      // Find any active timer for user
      for (const [key, timer] of this.storage.activeTimers.entries()) {
        if (timer.user === user) {
          timerKey = key;
          break;
        }
      }
    }

    if (!timerKey || !this.storage.activeTimers.has(timerKey)) {
      return {
        success: false,
        message: 'No active timer found',
        error: 'NO_ACTIVE_TIMER'
      };
    }

    const timer = this.storage.activeTimers.get(timerKey)!;

    if (action === 'pause') {
      if (timer.status === 'paused') {
        return {
          success: false,
          message: 'Timer is already paused',
          error: 'ALREADY_PAUSED'
        };
      }

      timer.status = 'paused';
      timer.pausedAt = new Date().toISOString();
      this.storage.activeTimers.set(timerKey, timer);
      await this.saveStorage();

      logger.info(`[TimeTracking] Paused timer for work item ${timer.workItemId}`);

      return {
        success: true,
        message: `Paused timer for work item ${timer.workItemId}`,
        data: {
          workItemId: timer.workItemId,
          status: 'paused',
          pausedAt: timer.pausedAt
        }
      };
    } else {
      // Resume
      if (timer.status !== 'paused' || !timer.pausedAt) {
        return {
          success: false,
          message: 'Timer is not paused',
          error: 'NOT_PAUSED'
        };
      }

      const pauseDuration = this.calculateDuration(timer.pausedAt, new Date().toISOString());
      timer.totalPausedDuration += pauseDuration;
      timer.status = 'active';
      delete timer.pausedAt;
      this.storage.activeTimers.set(timerKey, timer);
      await this.saveStorage();

      logger.info(`[TimeTracking] Resumed timer for work item ${timer.workItemId}`);

      return {
        success: true,
        message: `Resumed timer for work item ${timer.workItemId}`,
        data: {
          workItemId: timer.workItemId,
          status: 'active',
          pausedDuration: pauseDuration
        }
      };
    }
  }

  /**
   * Log work time manually
   */
  async logWorkTime(args: LogWorkTimeArgs): Promise<TimeTrackingResult> {
    await this.loadStorage();

    const { workItemId, organization, project, hours, date, description, billable, updateFields = true } = args;
    const user = this.getCurrentUser();

    if (hours <= 0) {
      return {
        success: false,
        message: 'Hours must be greater than 0',
        error: 'INVALID_HOURS'
      };
    }

    // Round duration
    const roundedHours = this.roundDuration(hours);

    const entryDate = date || new Date().toISOString().split('T')[0];
    const now = new Date().toISOString();

    // Create time entry
    const entry: TimeEntry = {
      id: uuidv4(),
      workItemId,
      startTime: `${entryDate}T00:00:00Z`,
      endTime: `${entryDate}T00:00:00Z`,
      duration: roundedHours,
      user,
      description,
      entryType: 'manual',
      billable,
      status: 'completed',
      createdAt: now,
      updatedAt: now
    };

    this.storage.timeEntries.set(entry.id, entry);
    await this.saveStorage();

    // Update ADO fields
    try {
      if (updateFields) {
        await this.updateWorkItemFields(organization, project, workItemId, roundedHours);
      }

      // Add time log comment
      const timeLog: TimeLogComment = {
        date: entryDate,
        startTime: '--:--',
        endTime: '--:--',
        duration: roundedHours,
        user,
        description,
        entryType: 'manual'
      };

      await this.addTimeLogComment(organization, project, workItemId, this.formatTimeLogComment(timeLog));

      // Get updated fields
      const repository = createWorkItemRepository(organization, project);
      const workItem = await repository.getById(workItemId);
      const completedWork = (workItem.fields['Microsoft.VSTS.Scheduling.CompletedWork'] as number) || 0;
      const remainingWork = (workItem.fields['Microsoft.VSTS.Scheduling.RemainingWork'] as number) || null;
      const percentComplete = remainingWork !== null
        ? Math.round((completedWork / (completedWork + remainingWork)) * 100)
        : 100;

      logger.info(`[TimeTracking] Logged ${roundedHours.toFixed(2)}h for work item ${workItemId}`);

      return {
        success: true,
        message: `Logged ${roundedHours.toFixed(2)} hours for work item ${workItemId}`,
        data: {
          workItemId,
          duration: roundedHours,
          completedWork,
          remainingWork: remainingWork || undefined,
          percentComplete
        }
      };
    } catch (error) {
      logger.error(`[TimeTracking] Failed to log time for work item ${workItemId}`, errorToContext(error));
      return {
        success: false,
        message: `Failed to log time: ${error instanceof Error ? error.message : String(error)}`,
        error: 'LOG_FAILED'
      };
    }
  }

  /**
   * Get active timers
   */
  async getActiveTimers(user?: string): Promise<ActiveTimersSummary> {
    await this.loadStorage();

    const currentUser = user || this.getCurrentUser();
    const timers: ActiveTimersSummary['timers'] = [];
    let totalElapsed = 0;

    for (const timer of this.storage.activeTimers.values()) {
      if (!user || timer.user === currentUser) {
        const now = new Date().toISOString();
        let elapsed = this.calculateDuration(timer.startTime, now);
        elapsed -= timer.totalPausedDuration;

        timers.push({
          workItemId: timer.workItemId,
          title: `Work Item ${timer.workItemId}`, // Could fetch actual title
          user: timer.user,
          startTime: timer.startTime,
          elapsedHours: elapsed,
          status: timer.status
        });

        totalElapsed += elapsed;
      }
    }

    return {
      activeCount: timers.length,
      timers,
      totalElapsedHours: totalElapsed
    };
  }

  /**
   * Generate time report
   */
  async getTimeReport(args: GetTimeReportArgs): Promise<TimeReport> {
    await this.loadStorage();

    const {
      organization,
      project,
      reportType,
      reportValue,
      startDate,
      endDate
    } = args;

    const start = startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    const end = endDate || new Date().toISOString().split('T')[0];

    // Filter entries
    const entries: TimeEntry[] = [];
    for (const entry of this.storage.timeEntries.values()) {
      const entryDate = entry.startTime.split('T')[0];
      if (entryDate >= start && entryDate <= end && entry.status === 'completed') {
        // Apply filters based on report type
        if (reportType === 'person' && entry.user !== reportValue) continue;
        if (reportType === 'workitem' && entry.workItemId.toString() !== reportValue) continue;
        // For iteration/project, would need to query work items
        
        entries.push(entry);
      }
    }

    // Aggregate data
    const byWorkItem: TimeReport['byWorkItem'] = {};
    const byPerson: Record<string, { totalHours: number; workItemCount: number; entryCount: number }> = {};
    const byDay: Record<string, { date: string; hours: number; entryCount: number }> = {};

    let totalHours = 0;
    const workItemIds = new Set<number>();

    for (const entry of entries) {
      const hours = entry.duration || 0;
      totalHours += hours;
      workItemIds.add(entry.workItemId);

      // By work item
      if (!byWorkItem[entry.workItemId]) {
        byWorkItem[entry.workItemId] = {
          workItemId: entry.workItemId,
          title: `Work Item ${entry.workItemId}`,
          type: 'Unknown',
          totalHours: 0,
          completedWork: 0,
          remainingWork: 0,
          percentComplete: 0,
          entryCount: 0
        };
      }
      byWorkItem[entry.workItemId].totalHours += hours;
      byWorkItem[entry.workItemId].entryCount++;

      // By person
      if (!byPerson[entry.user]) {
        byPerson[entry.user] = { totalHours: 0, workItemCount: 0, entryCount: 0 };
      }
      byPerson[entry.user].totalHours += hours;
      byPerson[entry.user].entryCount++;

      // By day
      const day = entry.startTime.split('T')[0];
      if (!byDay[day]) {
        byDay[day] = { date: day, hours: 0, entryCount: 0 };
      }
      byDay[day].hours += hours;
      byDay[day].entryCount++;
    }

    // Count unique work items per person
    const personWorkItems: Record<string, Set<number>> = {};
    for (const entry of entries) {
      if (!personWorkItems[entry.user]) {
        personWorkItems[entry.user] = new Set();
      }
      personWorkItems[entry.user].add(entry.workItemId);
    }
    for (const [user, workItems] of Object.entries(personWorkItems)) {
      byPerson[user].workItemCount = workItems.size;
    }

    return {
      generatedAt: new Date().toISOString(),
      scope: {
        type: reportType,
        value: reportValue
      },
      dateRange: {
        start,
        end
      },
      totalHours,
      workItemCount: workItemIds.size,
      entryCount: entries.length,
      byWorkItem,
      byPerson: reportType !== 'workitem' ? byPerson : undefined,
      byDay
    };
  }
}

// Export singleton instance
export const timeTrackingService = new TimeTrackingService();
